import csv
import json
import os
import re

# Path to your cloned ExploitDB folder, containing 'files_exploits.csv' and 'exploits/' subfolder
EXPLOITDB_ROOT = "../raw_data/exploitdb"
CSV_FILE       = "files_exploits.csv"
OUTPUT_FILE    = "../processed/exploitdb_extracted.jsonl"

# Regex patterns for typical exploit lines
PAYLOAD_PATTERNS = [
    r"<script>.*</script>",    # Basic XSS
    r"union\s+select",         # SQLi
    r"(\.\./)+",               # LFI
    r"(file:|php://|data://)", # LFI / local streams
    r"\bcurl\b.*http",         # SSRF / RCE
    r"system\s*\(",
    r"exec\s*\("
]

def load_csv_exploits(csv_path):
    """
    Load rows from ExploitDB's 'files_exploits.csv'.
    Returns a list of dictionaries with columns like 'file', 'description', etc.
    """
    rows = []
    try:
        with open(csv_path, mode="r", encoding="utf-8", errors="replace") as f:
            reader = csv.DictReader(f)
            for row in reader:
                rows.append(row)
    except FileNotFoundError:
        print(f"[ERROR] CSV not found: {csv_path}")
    return rows

def extract_payloads_from_exploit_file(file_path):
    """
    Read the exploit file line by line.
    Return any lines matching known injection patterns.
    """
    payloads_found = []

    # If file doesn't exist or is a directory, skip
    if not os.path.isfile(file_path):
        return payloads_found

    try:
        with open(file_path, "r", encoding="utf-8", errors="replace") as f:
            for line in f:
                stripped = line.strip().lower()
                # Check each pattern
                for pattern in PAYLOAD_PATTERNS:
                    if re.search(pattern, stripped):
                        # Store the original (un-lowered) line if you prefer
                        payloads_found.append(line.strip())
                        break
    except (UnicodeDecodeError, OSError) as e:
        # Could be a binary file or invalid characters
        return []

    return payloads_found

def main():
    # Full path to the CSV
    csv_path = os.path.join(EXPLOITDB_ROOT, CSV_FILE)
    csv_path = os.path.normpath(csv_path)

    if not os.path.exists(csv_path):
        print(f"[ERROR] CSV file not found at {csv_path}")
        return

    # Load rows from the CSV
    csv_exploits = load_csv_exploits(csv_path)
    all_records = []

    for row in csv_exploits:
        # e.g. 'exploits/php/webapps/12345.py'
        file_rel = row.get("file", "")
        if not file_rel:
            continue

        # Normalize the path so Windows doesn't choke on mixed slashes
        exploit_file_path = os.path.join(EXPLOITDB_ROOT, file_rel)
        exploit_file_path = os.path.normpath(exploit_file_path)

        # Extract lines that match known exploit patterns
        found_lines = extract_payloads_from_exploit_file(exploit_file_path)
        if not found_lines:
            continue

        for line in found_lines:
            record = {
                "vulnerability_type": "unknown",
                "payload": line,
                "source": "ExploitDB",
                "description": row.get("description", ""),
                "file_path": file_rel
            }
            low_line = line.lower()

            # Very naive classification
            if "<script>" in low_line:
                record["vulnerability_type"] = "xss"
            elif "union select" in low_line:
                record["vulnerability_type"] = "sql_injection"
            elif "../" in low_line:
                record["vulnerability_type"] = "lfi"
            elif "exec(" in low_line or "system(" in low_line:
                record["vulnerability_type"] = "rce"

            all_records.append(record)

    # Create the output directory if needed
    os.makedirs(os.path.dirname(OUTPUT_FILE), exist_ok=True)
    # Write all records to JSONL
    with open(OUTPUT_FILE, "w", encoding="utf-8") as out:
        for item in all_records:
            out.write(json.dumps(item) + "\n")

    print(f"[+] Done! Found {len(all_records)} payload lines in exploit files.")
    print(f"[+] Output file: {OUTPUT_FILE}")

if __name__ == "__main__":
    main()